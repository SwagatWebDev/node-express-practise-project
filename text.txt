private EventLogProjection pickRecordWithMinOldValueAndMaxNewValue(List<EventLogProjection> eventsWithSameNamePathAndDay) {
    // Group events by eventCreatedDate
    Map<String, List<EventLogProjection>> eventsByDate = eventsWithSameNamePathAndDay.stream()
            .collect(Collectors.groupingBy(event ->
                    event.getEventCreatedDate().substring(0, 10)));

    // Process each group to find the unique record
    Map<String, EventLogProjection> uniqueRecords = new HashMap<>();
    for (List<EventLogProjection> eventsOnSameDay : eventsByDate.values()) {
        // Find the event with the lowest eventCreatedDate on the same day
        EventLogProjection minDateEvent = eventsOnSameDay.stream()
                .min(Comparator.comparing(EventLogProjection::getEventCreatedDate))
                .orElseThrow();

        // Update the unique record with the lowest eventCreatedDate
        uniqueRecords.put(minDateEvent.getOldValue(), minDateEvent);
    }

    // Find the record with the highest newValue based on event created date
    return uniqueRecords.values().stream()
            .max(Comparator.comparing(EventLogProjection::getNewValue)
                    .thenComparing(EventLogProjection::getEventCreatedDate,
                            Comparator.nullsLast(Comparator.naturalOrder())))
            .orElseThrow(); // Handle as per your logic
}
