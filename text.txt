import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.apache.commons.lang3.StringUtils;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Service
public class EventLogService {

    @Override
    public Page<EventLogDto> getEventLog(Pageable pageable) {
        Page<EventLogProjection> eventLogData = eventLogRepository.getEventLogData(pageable);
        List<EventLogDto> combinedEventLogDtoList = getCombinedEventLogDtoList(eventLogData.getContent());
        return new PageImpl<>(combinedEventLogDtoList, pageable, eventLogData.getTotalElements());
    }

    private List<EventLogDto> getCombinedEventLogDtoList(List<EventLogProjection> eventLogData) {
        return Stream.concat(
                processGroupedEvents(eventLogData),
                processUnGroupedEvents(eventLogData)
        ).collect(Collectors.toList());
    }

    private Stream<EventLogDto> processGroupedEvents(List<EventLogProjection> eventLogData) {
        return eventLogData.stream()
                .collect(Collectors.partitioningBy(this::isMatchingPath))
                .get(true).stream()
                .collect(Collectors.groupingBy(
                        event -> event.getName() + event.getEventCreatedDate().substring(0, 10),
                        Collectors.collectingAndThen(Collectors.toList(), events ->
                                processEventLogMappingResult(events.stream()
                                        .max(Comparator.comparing(EventLogProjection::getEventCreatedDate))
                                        .orElseThrow(NoSuchElementException::new),
                                        events.get(0).getOldValue())
                        )
                ))
                .values().stream()
                .map(this::mapToEventLogDto);
    }

    private Stream<EventLogDto> processUnGroupedEvents(List<EventLogProjection> eventLogData) {
        return eventLogData.stream()
                .filter(event -> !isMatchingPath(event))
                .map(event -> processEventLogMappingResult(event, event.getOldValue()))
                .map(this::mapToEventLogDto);
    }

    private EventLogMappingOto processEventLogMappingResult(EventLogProjection eventLogProjectionData, String oldValue) {
        return new EventLogMappingOto()
                .withOldValue(oldValue)
                .withEventType(eventLogProjectionData.getEventType())
                .withName(eventLogProjectionData.getName())
                .withEventCreatedDate(eventLogProjectionData.getEventCreatedDate())
                .withAssetType(eventLogProjectionData.getAssetType())
                .withChangedBy(eventLogProjectionData.getChangedBy())
                .withFullPathName(eventLogProjectionData.getFullPathName())
                .withNewValue(eventLogProjectionData.getNewValue())
                .withPath(eventLogProjectionData.getPath());
    }

    private EventLogDto mapToEventLogDto(EventLogMappingOto event) {
        return new EventLogDto()
                .withName(event.getName())
                .withEventCreatedDate(event.getEventCreatedDate())
                .withChangedBy(event.getChangedBy())
                .withAssetType(event.getAssetType())
                .withEventType(getEventType(event.getPath()))
                .withOldValue(event.getOldValue())
                .withNewValue(getProcessedNewValue(event.getNewValue(), event.getEventType()))
                .withFullPathName(event.getFullPathName());
    }

    private String getEventType(String path) {
        return StringUtils.isNotEmpty(path) ? "New" : switch (path) {
            case "'status" -> "Delete";
            case "'relSolutionToCapability", "'relSolutionToBusinessCapability", 'relCapabilityToSolution" -> "Capability";
            case "'relSolutionToCapability'usageDisposition", "'relSolutionToBusinessCapability'usageDisposition", 'relCapabilityToSolution'usageDisposition" -> "Disposition";
            default -> "";
        };
    }

    private String getProcessedNewValue(String newValue, String eventType) {
        return switch (eventType) {
            case "New", "Disposition" -> removeContentInsideParenthesesAndSquareBracket(newValue);
            case "Capability" -> extractValueFromBusinessCapability(newValue);
            default -> newValue;
        };
    }

    private String extractValueFromBusinessCapability(String newValue) {
        return StringUtils.isNotBlank(newValue) ? Optional.ofNullable(newValue.replaceAll(".*BusinessCapability : %\\((.*?)%.*", "$1"))
                .filter(result -> !result.contains("[Deleted Fact Sheet)"))
                .orElse(newValue)
                : newValue;
    }

    private String removeContentInsideParenthesesAndSquareBracket(String newValue) {
        int start = newValue.indexOf("(");
        return (start >= 0) ? newValue.substring(0, start).trim() : newValue;
    }
}
