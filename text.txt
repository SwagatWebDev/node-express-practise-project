private EventLogProjectionResult pickRecordWithMinAndMaxValues(
        List<EventLogProjection> events,
        Function<EventLogProjection, String> oldValueExtractor,
        Function<EventLogProjection, String> newValueExtractor) {

    EventLogProjection minOldValueEvent = events.stream()
            .min(Comparator.comparing(
                    oldValueExtractor,
                    Comparator.nullsLast(Comparator.naturalOrder()))
                    .thenComparing(
                            EventLogProjection::getEventCreatedDate,
                            Comparator.nullsLast(Comparator.naturalOrder())))
            .orElseThrow(); // Handle as per your logic

    EventLogProjection maxNewValueEvent = events.stream()
            .filter(event -> Objects.equals(oldValueExtractor.apply(event), minOldValueEvent.getOldValue()))
            .max(Comparator.comparing(
                    newValueExtractor,
                    Comparator.nullsLast(Comparator.naturalOrder()))
                    .thenComparing(
                            EventLogProjection::getEventCreatedDate,
                            Comparator.nullsLast(Comparator.naturalOrder())))
            .orElseThrow(); // Handle as per your logic

    // Null check before calling contains
    String minOldValue = minOldValueEvent.getOldValue();
    String maxNewValue = maxNewValueEvent.getNewValue();

    if (minOldValue != null && maxNewValue != null && maxNewValue.contains(minOldValue)) {
        // Modify other fields if necessary
        return new EventLogProjectionResult(minOldValue, maxNewValue);
    } else {
        // Handle the case when either minOldValue or maxNewValue is null or maxNewValue doesn't contain minOldValue
        return new EventLogProjectionResult(minOldValue, maxNewValue);
    }
}
